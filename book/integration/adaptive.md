---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Julia
  language: julia
  name: julia-1.6
---

```{code-cell}
:tags: [remove-cell]

include("../src.jl")
```

# Адаптивное интегрирование

Рассмотренные ранее методы интегрирования, не считая метода Гаусса, используют равномерные сетки. Взглянем на следующий пример.

```{proof:demo}
```
```{raw} html
<div class="demo">
```

Допустим, нам нужно проинтегрировать функцию $x \sin(2x/(x-2))$. Её график выглядит следующим образом

```{code-cell}
foo(x) = x * sin(2x/(x-2))
plot(foo, 0, 1.85; xlabel=L"x", ylabel=L"f(x)", label="")
```

Видно, что данная функция по-разному "изменчива" на разных участках:

- справа разрешение колебания требует мелкую сетку, причём чем ближе к $x=2$, тем мельче;
- слева же функция меняется плавно, поэтому подойдёт и крупная сетка. 

Применение метода, основанного на равномерной сетке, приводит к перевычислениям.

Например, для метода Ромберга получим

```{code-cell}
foo(x) = x * sin(2x/(x-2))
r01 = rombergwstep(foo, 0, 1; atol=1e-6)
r12 = rombergwstep(foo, 1, 1.999; atol=1e-6)
r02 = rombergwstep(foo, 0, 1.999; atol=1e-6)
r01, r12, r02
```

`rombergwstep` отличается от {numref}`Функции {number} (romberg) <function:romberg>` только тем, что возвращает кортеж `(I[1, i], i)`. То есть, вычисления слева можно было бы закончить уже после 7 разбиений.

```{raw} html
</div>
```

```{index} алгоритм; адаптивный
```
Алгоритмы, которые подбирают шаг сетки автоматически, называются **адаптивными**.

## Идея

Изложенную здесь идею подробнее можно почитать, например, здесь {cite}`SamarskiyGulin1989`, {cite}`fnc2017`.

Допустим, мы вычисляем часть интеграла на отрезке $\int_{x_{i-1}}^{x_i} f\diff x$. Чтобы понять, нужно ли дробить отрезок для повышения точности, можно рассмотреть два приближения интеграла и сравнить их. Если разница не удовлетворяет заданной "точности", то отрезок $[x_{i-1}, x_i]$ дробится пополам, а вычисления по *тем же* квадратурам происходят уже на более мелких отрезках.

Два приближения вычислим по формулам Симпсона {eq}`simp_final` на разных сетках

```{math}
\begin{align}
S_f(h/2) &= \frac{1}{3}\big[4T_f(h/2) - T_f(h)\big],\\
S_f(h/4) &= \frac{1}{3}\big[4T_f(h/4) - T_f(h/2)\big],\\
h &= x_i - x_{i-1}.
\end{align}
```

Всего на шаге интегрирования потребуется 5 вычислений функции $f$ в точках $x_{i-1}$, $x_{i-1} + h/4$, $x_{i-1} + h/2$, $x_{i-1} + 3h/4$, $x_i$ для получения $T_f(h)$, $T_f(h/2)$ и $T_f(h/4)$.

```{margin}
Формула Ромберга получается из экстраполяции Ричардсона.
```
Формула Симпсона имеет четвёртный порядок сходимости, а следующая за ней в экстраполяции формула Ромберга $R_f$

```{math}
R_f(h/4) = \frac{1}{15}\big[16 S_f(h/4) - S_f(h/2) \big]
```

имеет уже шестой порядок сходимости.

Приближениями $S_f(h/4)$, $R_f(h/4)$ воспользуемся для апостериорной оценки погрешности

```{math}
E = R_f(h/4) - S_f(h/4) = \frac{S_f(h/4) - S_f(h/2)}{15},
```

которую и будем использовать для критерия разбиения отрезка.

*Критерий разбиения* нужно выбирать аккуратно. Дело в том, что по значению входных данных (т.е. функции $f$ и отрезка) нельзя оценить величину интеграла: будет ли она маленькой или большой. Поэтому полагаться нужно сразу на относительную $\delta_r$ и абсолютную $\delta_a$ "точности"

```{math}
:label: int_adaptive_criterion

|E| < \delta_a + \delta_r |S_f(h/4)|.
```

Если наше приближение к интегралу $S_f \approx 0$ мало (интеграл от нечётной функции, например), то работает абсолютная погрешность $\delta_a$. Если же $S_f$ велико, то {eq}`int_adaptive_criterion` требует, чтобы разница приближений $|E|$ составляла меньше некоторой части $\delta_r$ от приближения $|S_f|$.

## Реализация

