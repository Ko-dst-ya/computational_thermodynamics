# Метод Ромберга

*Метод Ромберга* (*Romberg's method*) позволяет быстро интегрировать с заданной точностью. Метод основывается на применении экстраполяции Ричардсона к формуле трапеций при удвоении числа узлов.

## Экстраполяция Ричардсона

Рассмотрим вычисление интеграла $I_h$ на равномерной сетке с шагом $h$. На каждом интервале отрезка применяется одна и та же квадратурная формула. Для некоторых формул (например, для формулы трапеций) удаётся получить вид погрешности $I - I_h$. Предположим, что это разложение выглядит так

```{math}
I_h = I + a_1 h^{\alpha_1} + a_2 h^{\alpha_2} + ... + a_m h^{\alpha_m} + O(h^{\alpha_{m+1}}).
```

## Удвоение числа узлов

Рассмотрим равномерную сетку $a = x_0 < x_1 < x_2 < x_3 < x_4 = b$ из $n=4$ интервалов с шагом $h_4$ и сетку из $n=2$ интервалов $a = x_0 < x_2 < x_4 =b$ с шагом $2h_4$.

%%% todo: сюда бы картинку

На крупной сетке формула трапеций даёт

```{math}
:label: doubling_tf2

T_f(n=2) = 2h_4 \Big[0.5 \big(f(x_0) + f(x_4)\big) + f(x_2)\Big].
```

А на сетке вдвое мельче

```{math}
:label: doubling_tf4

T_f(n=4) = h_4 \Big[ 0.5 \big(f(x_0) + f(x_4)\big) + f(x_1) + f(x_3) \Big].
```

Сравнивая {eq}`doubling_tf2` и {eq}`doubling_tf4`, обнаруживаем их связь

```{math}
T_f(n=4) = 0.5 T_f(n=2) + h_4 \big(f(x_1) + f(x_3)\big).
```

Таким образом, мы в частном случае получили, что вычислив интеграл на крупной сетке, мы можем вычислить его на сетке вдвое мельче, используя только значения в *новых узлах* ($x_1$, $x_3$).

Это верно и в общем случае

```{math}
T_f(2n) = 0.5 T_f(n) + h_{2n} \sum_{i=1}^n f(x_{2i-1}), \quad h_{2n} = \frac{b-a}{2n},\quad x_{2i-1} = a + h_{2n} (2i-1).
```

Данная формула позволяет вычислить интеграл с заданной точностью. Под точностью здесь понимается разница между новой аппроксимацией и старой

```{math}
:label: doubling_tol

|T_f(2n) - T_f(n)| < \text{tol}.
```

Например, при $\text{tol} = 10^{-6}$ мы можем добиться точности до 6 знаков после запятой. Конечно, ошибки округления и обусловленность задачи никуда не делись.

Также отметим, что выражение {eq}`doubling_tol` является абсолютной, а не относительной точностью.

Реализация может быть такой

:::{proof:function} trapezoid_tol

**Формула трапеций с контролем точности**

```julia
"""
Вычисляет интеграл ∫`f`dx на [`a`, `b`] с точностью `atol` по формуле трапеций,
удваивая число разбиений интервала, но не более `maxstep` раз.
Возвращает значение интеграла.
"""
function trapezoid_tol(f, a, b; atol=1e-3, maxstep=100)
    nc, hc = 1, b - a
    Tc = hc * (f(a) + f(b)) / 2
    for step in 1:maxstep
        Tp, np = Tc, nc
        hc /= 2
        nc *= 2
        Tc = Tp / 2 + hc * sum(f, (a + hc*(2i-1) for i in 1:np))
        abs(Tc - Tp) < atol && return Tc
    end
    error("Точность не удовлетворена.")
end
```
:::

<!-- Бывает так, что вычисление функции в точке $f(x)$ &ndash; трудоёмкая операция, при этом хпоэтому требуется как можно чаще избегать перевычислений.
 -->

<!-- ## Метод Ромберга -->
