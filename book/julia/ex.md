# Задания

## Точки

Это ознакомительное задание для освоения языка Julia. Вам необходимо разработать пакет (package), содержащий один модуль, несколько структур данных и функций.

Файлы для разработки пакета уже сгенерированы и находятся в репозитории [CTTaskPoints](https://github.com/stepanzh/CTTaskPoints). Вам же необходимо работать в директории `srс/`, дописав модуль Points до конца.

В задание встроена система тестов для самопроверки.

Все инструкции по скачиванию задания и системы самопроверки находятся в репозитории.

### Содержание задания

Необходимо дописать модуль Points, реализовав следующее.

Структура данных `Point`, отвечающая за точку на декартовой плоскости.

- Конструктор: `Point(x, y)`.

Линейные операции с точками:

- Сложение;
- Вычитание;
- Умножение на скаляр;
- Деление на скаляр. Деление на ноль при этом особым образом не обрабатывается;
- Реализация должна расширять стандартные операторы `+`, `-`, `*` и `\`.

У точек должны быть операции скалярного произведения и евклидовой нормы. При этом необходимо перегрузить операции стандартного модуля линейной алгебры: `LinearAlgebra.dot(p, q)` и `LinearAlgebra.norm(p)`.

Написать функцию `center(points)`, находящую "центр масс" точек.

- Аргумент `points`: коллекция точек, например, вектор из точек;
- Возвращаемое значение -- точка `Point`;
- Примеры:
  + `center([Point(0, 0), Point(0, 1)]) == Point(0, 0.5)`;
  + `center([Point(1, 1)]) == Point(1, 1)`;
- Желательно, чтобы аргумент `points` мог быть любой коллекцией, но достаточно сделать реализацию для вектора из точек.

Написать функцию поиска k-ближайших соседей `neighbors(points, origin, k)`, в качестве расстояния используется евклидово расстояние.

- Аргумент `points`: коллекция точек, среди которых ищутся соседи;
- Аргумент `origin`: точка, соседи которой ищутся, может содержаться в `points`;
- Аргумент `k`: целое количество соседей, необходимое найти. В случае поиска нулевого или отрицательного количества соседей считать, что соседей нет;
- Возвращаемое значение: вектор точек `Vector{<:Point}`.

Структура данных `Circle`, отвечающая за круговую область

- Конструкор: `Circle(o, radius)`, где `o <: Point` -- центр круга, а `radius` радиус круга.

Структура данных `Square`, отвечающая за квадратную область со сторонами, параллельными осям координат.

- Конструктор: `Square(o, side)`, где `o <: Point` -- центр квадрата, а `side` длина его стороны.

Операция принадлежности точки области

- Перегружать стандартный оператор `in`;
- Для `Circle` и `Square`;
- Области считать замкнутыми: если точка попадает на границу области, считать, что она ей принадлежит;
- Примеры:
  +  `Point(0, 0) in Circle(Point(0, 0.5), 1)  # true`;
  + `Point(0, 0) in Circle(Point(0, 0.5), 0.5)  # true`.

Написать метод `center(points, area)` для функции `center`, находящий "центр масс" точек, принадлежащих области

- Аргумент `points`: коллекция точек. Гарантируется, что хотя бы одна из точек принадлежит области `area`;
- Аргумент `area`: `Circle` или `Square` -- область, 
- Возвращаемое значение: точка `Point`;
- Примеры:
  + `center([Point(0, 0), Point(1, 0)], Circle(Point(0.75, 0), 0.25)) == Point(1, 0)`;
  + `center([Point(0, 0), Point(1, 0)], Circle(Point(0.75, 0), 0.76)) == Point{Float64}(0.5, 0.0)`;
- Желательно, чтобы аргумент `points` мог быть любой коллекцией, но достаточно сделать реализацию для вектора из точек.
  
Бонусы:

- Стабильность по типам функции `neighbors`;
- Стабильность по типам вызова `center(points, ::Circle)`;
- Стабильность по типам вызова `center(points, ::Square)`.
