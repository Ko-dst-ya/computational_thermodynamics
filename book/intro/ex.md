# Задачи

## Точки

*Данное задание можно выполнять в парах. В таком случае один человек в команде реализует интерфейс для `CartesianPoint`, а второй для `PolarPoint`*.

Создайте модуль `Points`, предназначенный для работы с точками на плоскости. Реализуйте описанные ниже структуры данных и интерфейс к ним.

Создайте две структуры данных для точки на плоскости

1. Композитный тип `CartesianPoint`: хранит декартовы координаты точки;
2. Композитный тип `PolarPoint`: хранит полярные координаты точки.

Оба типа должны быть подтипом абстрактного типа `AbstractPoint`.

К каждой структуре данных имплементируйте следующий интерфейс (точки `p` и `q` одного типа)

Сложение `p + q`
: Вовзращает новую точку как результат векторного сложения точек `p` и `q`.

Вычитание `p - q`
: Возвращает новую точку как результат векторного вычитания из точки `p` точки `q`.

Длина `norm(p)`
: Вовзращает длину радиус-вектора точки `p`.

Аргумент `arg(p)`
: Возвращает угол (в радианах) между радиус вектором точки и осью абсцисс.

Угол между радиус-векторами `angle(p, q)` и `∠(p, q)`
: Возвращает угол между радиус-векторами точек `p` и `q`.

Растяжение `α * p`
: Возвращает новую точку, получающуюся в результате центрального растяжения (`α > 1`) или сжатия (`0 < α < 1`) радиус вектора точки `p` в `α::Real` раз. Например, точка `(5, 6)` при `α = 2.5` переходит в точку `(12.5, 15.0)`.

Поворот `rotate(p, φ)`
: Возвращает новую точку, получающуюся поворотом точки `p` на угол `φ` против часовой стрелки.

Также имплементируйте интерфейс перевода из точки из одного типа во второй (см. **[[url]](https://docs.julialang.org/en/v1/manual/constructors/#man-outer-constructor-methods)**)

`CartesianPoint(p::PolarPoint)`
: Создает соответствующую точку типа `CartesianPoint` из точки типа `PolarPoint`.

`PolarPoint(p::CartesianPoint)`
: Создает соответствующую точку типа `PolarPoint` из точки типа `CartesianPoint`.


В качестве ответа требуется:

- исходные файлы модуля `Points`;
- файл, импортирующий модуль `Points` и демонстрирующий весь рабочий интерфейс.
