# Функции

Функция в Julia один из основных инструментов повторного использования кода.

Больше информации в мануале **[[url]](https://docs.julialang.org/en/v1/manual/functions/)**.


Основной синтаксис для функций в Julia

```julia-repl
julia> function f(x, y)
           return sqrt(x^2 + y^2)
       end
f (generic function with 1 method)
```

Строго говоря, команда `return` необязательна: функция в Julia возвращает результат последнего выражения, однако, мы будем придерживаться [![Code Style: Blue](https://img.shields.io/badge/code%20style-blue-4495d1.svg)](https://github.com/invenia/BlueStyle).

```{margin}
Раз есть тип `Nothing`, есть и `Something`!
```
В теле функции может находиться несколько команд `return`, в этом случае при вызове сработает только одна из них.
Если необходимо, чтобы функция ничего не возвращала, тогда используется `return nothing`.
Тип `Nothing` имеет лишь одно значение `nothing`, представляющее в Julia отутствие значения.

Зачастую пригождается более краткий синтаксис создания функции (*assignment form*)

```julia-repl
julia> f(x, y) = sqrt(x^2 + y^2)
f (generic function with 1 method)
```

В этом случае справа от `=` может находиться составное выражение (*compound expression*) `begin-end`.

```julia-repl
julia> g(x, y) = begin              # или g(x, y) = begin z = f(x, y); return 2*z end
           z = f(x, y)
           return 2*z
       end
g (generic function with 1 method)
```

:::{admonition} О составных выражениях
:class: dropdown

Блок `begin-end` позволяет объединять несколько выражений в одно, составное выражение (*compound expression*). Результат выражения это результат последнего вычисления в выражении.

```julia-repl
julia> z = begin
           x = 1
           y = 2
           x + y
       end
3

julia> x, y
(1, 2)
```

Как видно из примера, `begin-end` исполняется во внешнем пространстве имён. Его двойник блок `let-end` создаёт собственное пространство имён. Внутри `let-end` можно пользоваться именами извне, но если происходит присвоение, то имя создаётся внутри видимости `let-end`.

```julia-repl
julia> x, y = 1, 2
(1, 2)

julia> let
           x = 10
           y = 20
           x + y
       end
30

julia> x, y
(1, 2)
```

С помощью `;` можно поместить несколько выражений на одной строке, что часто используется для коротких составных выражений или депривации вывода в REPL.

```julia-repl
julia> z = (x = 1; y = 2; x + y)
3

julia> z = begin x = 1; y = 2; x + y end
3
```

Предназначение `;` аналогично его предназначению в C-подобных языках, но в Julia не требуется ставить `;` после каждой инструкции.
:::

Синтаксис вызова интуитивен

```julia-repl
julia> f(3, 4)
5.0

julia> g(3, 4)
10.0
```

В Julia аргументы передаются по принципу *pass-by-sharing*. Т.е. аргументы функции внутри тела ведут себя как новые переменные. Однако, у изменяемых *mutable* аргументов (например, массив), можно поменять значения, и они будут видны извне. По соглашению, если функция меняет свой аргумент, то в её имя добавляется `!` в конце, например, `map!(f, A, B)`, `push!(A, x)` (исключение составляют функции, работающие с вводом-выводом `print`, `write`,..).

Функции являются **first-class** объектами. Ими можно "распоряжаться", как переменными: присваивать их другим переменным, передавать как аргумент... 

```julia-repl
julia> φ = f;

julia> φ(3, 4)
5.0
```

Важно, что операторы в Julia также являются функциями

```julia-repl
julia> +(1, 2, 3) == 1 + 2 + 3
true
```

Языковые конструкции, вроде доступа к элементу массива (`A[i]`) или полю структуры (`S.x`) являются операторами c функциональными аналогами.

Можно создавать анонимные функции

```julia-repl
julia> x -> 2x                        # короткий синтаксис
#1 (generic function with 1 method)

julia> f4 = x -> 2x                   # анонимная функция x -> 2x присвоена переменной f4
#3 (generic function with 1 method)

julia> f4(8)
16

julia> function (x)                   # длинный синтаксис
           return 3x
       end
#5 (generic function with 1 method)

julia> map(x -> 3x, 1:4)              # пример применения
4-element Vector{Int64}:              # map здесь создает массив
  3                                   # из утроенных значений
  6                                   # арифм. прогрессии от 1 до 4
  9
 12
```

В Julia тип, соответствующий аргументам функции, является кортежем `Tuple`. Кортеж неизменная коллекция.

```julia-repl
julia> tup = (3, 4)
(3, 4)

julia> tup[1]
3

julia> (3,)  # tuple из одного значения
(3,)
```

Функция, конечно, может и возращать `Tuple`, т.е. возвращать несколько значений. Если абстрагироваться, функция в Julia создаёт из одного кортежа значений другой кортеж.

```julia-repl
julia> function addmul(x, y)
           return x + y, x * y
       end
addmul (generic function with 1 method)

julia> a, b = addmul(3, 4)
(7, 12)

julia> a
7

julia> b
12
```

Также существует именованный кортеж `NamedTuple`, хранящий пары ключ-значение. На его основе создаются функции, принимающие аргументы по ключу.

И можно присваивать аргументам значения по умолчанию.

```julia
# x - позиционный, p - именованный со значением по умолчанию
julia> f(x; p=10) = p * x
f (generic function with 1 method)

julia> f(1)
10

julia> f(2; p=20)
40
```
